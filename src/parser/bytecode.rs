//! code for generating JVM-bytecode out of an AST and a symbol table for a JavaSST class

use std::cmp::max;
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;
use std::ops::Deref;
use derivative::Derivative;
use crate::parser::ast::{Binop, Node, SyntaxElement};
use crate::parser::bytecode::CPoolEntry::CONSTANT_Utf8;
use crate::parser::error::ParseResult;
use crate::parser::sym_table::{ResultType, SymEntry, SymTable, Type};

/// takes an AST and creates JVM-bytecode from it for the given class
pub fn generate(ast: &Node) -> ParseResult {
    // get the name of the class, as we need it in the bytecode and later to name the file
    let class_entry = ast.get_obj().as_ref().expect("starting class node without obj").deref().borrow();
    let class_name = class_entry.name();

    // get the class sym table out of the head table (as the class' table is the only table we really care about)
    let table_rc = class_entry.sym_table().unwrap();
    let table = table_rc.deref().borrow();

    // start with an empty vec of bytes to be filled with the generated bytecode
    let mut bytecode: Vec<u8> = vec![];

    write_head(&mut bytecode);

    // create the constant_pool and write it to the buffer
    let constant_pool = ConstantPool::new(ast, &table);
    constant_pool.flush(&mut bytecode);
    
    write_access_flags(&mut bytecode);
    write_class_indexes_and_interfaces(&mut bytecode, &constant_pool, class_name);
    write_fields(&mut bytecode, ast.borrow_left().unwrap(), &table, &constant_pool);
    write_methods(&mut bytecode, &table, &constant_pool, ast);
    write_attributes(&mut bytecode, &constant_pool, class_name);

    // open a new output file and write all bytes into it
    let mut file = File::create(format!("{}.class", class_name)).expect("couldn't create file o.class");
    file.write(bytecode.as_slice()).unwrap();

    Ok(())
}
/// there is only one attribute for a class: its source file name
fn write_attributes(bytecode: &mut Vec<u8>, constant_pool: &ConstantPool, class_name: &str) {
    bytecode.extend_from_slice(&1u16.to_be_bytes());    // attribute count
    let SourceFile_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8("SourceFile".to_string())).unwrap();
    bytecode.extend_from_slice(&SourceFile_index.to_be_bytes());    // attribute name index
    bytecode.extend_from_slice(&2u32.to_be_bytes());    // attribute length
    let mut file_name = class_name.to_string();
    file_name.push_str(".class");
    let file_name_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8(file_name)).unwrap();
    bytecode.extend_from_slice(&file_name_index.to_be_bytes());    // file name index
}

fn write_methods(bytecode: &mut Vec<u8>, table: &SymTable, constant_pool: &ConstantPool, ast: &Node) {
    // start with the number of methods
    let method_count = (table.procedures().count()) as u16;
    bytecode.extend_from_slice(&method_count.to_be_bytes());    // method count
    //bytecode.extend_from_slice(&1u16.to_be_bytes());    // method count DEBUG
    /* STRUCTURE (https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.6)
    method_info {
        u2             access_flags;
        u2             name_index;
        u2             descriptor_index;
        u2             attributes_count;
        attribute_info attributes[attributes_count];
    }
     */
    for (method_name, sym_entry) in table.procedures() {
        // access_flags
        bytecode.extend_from_slice(b"\x00\x09");    // static (0x0008) and public (0x0001)
        // name_index
        let name_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8(method_name.clone())).unwrap();
        bytecode.extend_from_slice(&name_index.to_be_bytes());
        // descriptor_index
        let sym_entry = sym_entry.deref().borrow();
        let m_descriptor = ConstantPool::method_descriptor(&sym_entry);
        let descriptor_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8(m_descriptor)).unwrap();
        bytecode.extend_from_slice(&descriptor_index.to_be_bytes());
        // attributes_count
        // There's just one attribute: the "Code" attribute
        bytecode.extend_from_slice(&1u16.to_be_bytes());
        // attributes (there is only one: Code)
        // Code attribute: (https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.3)
        /*
        Code_attribute {
            u2 attribute_name_index;
            u4 attribute_length;
            u2 max_stack;
            u2 max_locals;
            u4 code_length;
            u1 code[code_length];
            u2 exception_table_length;
            {   u2 start_pc;
                u2 end_pc;
                u2 handler_pc;
                u2 catch_type;
            } exception_table[exception_table_length];
            u2 attributes_count;
            attribute_info attributes[attributes_count];
        }
        */
        // attribute_name_index (of the name "Code")
        let attribute_name_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8("Code".to_string())).unwrap();
        bytecode.extend_from_slice(&attribute_name_index.to_be_bytes());
        // next generate and store the attribute in a new buffer, so that its size can be determined
        // and then written to the bytecode BEFORE the attribute itself
        let mut attr_buffer = Vec::<u8>::new();
        // for the following we need the part of the AST that contains the method definition, so we first find that node
        // the right child of the class node is the first 'Enter'
        let mut enter_option = ast.borrow_right();
        while let Some(enter_node) = enter_option {
            if enter_node.get_obj().as_ref().unwrap().deref().borrow().name() == method_name.as_str() {
                // match found
                break;
            }
            enter_option = enter_node.borrow_link();
        }
        let enter_node = enter_option.unwrap();

        // for the code itself again generate a new buffer for the same reasons as with the attribute
        let mut current_stack = 0;
        let mut max_stack = 0;
        let code_buffer = method_bytecode(enter_node.borrow_right(),
                                          constant_pool,
                                          &sym_entry.sym_table().unwrap().deref().borrow(),
                                          sym_entry.params().unwrap(),
                                          &mut current_stack,
                                          &mut max_stack,
                                 true
        );
        // max_stack
        attr_buffer.extend_from_slice(&max_stack.to_be_bytes());
        // max_locals
        let max_locals = max_locals(enter_node);
        attr_buffer.extend_from_slice(&max_locals.to_be_bytes());
        // code_length
        attr_buffer.extend_from_slice(&(code_buffer.len() as u32).to_be_bytes());
        // code
        attr_buffer.extend_from_slice(code_buffer.as_slice());
        // exception_table_length (no exceptions so always 0)
        attr_buffer.extend_from_slice(&0u16.to_be_bytes());
        // #######################
        // # CODE ATTRIBUTE INFO #
        // #######################
        // attributes_count (zero, as LineNumberTables are optional and therefore currently not implemented,
        // and StackMapFrames aren't (since Java 7, which is the oldest version still supported by current compilers), but if we stick to older compilers we can just skip it for now as well)
        attr_buffer.extend_from_slice(&0u16.to_be_bytes());
        // code attribute (StackMapFrame)
        //add_stack_map_frame(&mut attr_buffer);
        //add_line_number_table(&mut attr_buffer);

        // attribute_length
        bytecode.extend_from_slice(&(attr_buffer.len() as u32).to_be_bytes());
        // attribute
        bytecode.extend_from_slice(attr_buffer.as_slice());
    }
}

/// generates the actual bytecode for a method (or parts of it, recursively)
fn method_bytecode(mut node_option: Option<&Node>, constant_pool: &ConstantPool, sym_table: &SymTable, params: &[(Type, String)], current_stack: &mut u16, max_stack: &mut u16, follow_link: bool) -> Vec<u8> {
    fn increase_stack(current_stack: &mut u16, max_stack: &mut u16) {
        *current_stack += 1;
        *max_stack = max(*current_stack, *max_stack);
    }
    fn decrease_stack(current_stack: &mut u16) {
        *current_stack -= 1;
    }

    use ByteInstruction::*;
    let mut bytecode = Vec::<u8>::new();

    while let Some(node) = node_option {
        match node.node_type() {
            SyntaxElement::Call => {
                let method_rc = node.get_obj().as_ref().unwrap();
                let method_entry = method_rc.deref().borrow();
                // first lay all necessary parameters on the stack, in normal order, not inverted one
                let argument_count = method_entry.params().unwrap().len();
                let mut arg_option = node.borrow_left();
                while let Some(arg_node) = arg_option {
                    // execute the node, so that the necessary argument afterwards lies on the stack
                    // DON'T FOLLOW THE LINKS OF ARGUMENT NODES, OR ARGUMENTS WILL BE EXECUTED MULTIPLE TIMES
                    bytecode.extend_from_slice(method_bytecode(arg_option, constant_pool, sym_table, params, current_stack, max_stack, false).as_slice());

                    arg_option = arg_node.borrow_link();
                }

                // write the opcode and the methodref index
                bytecode.push(invokestatic as u8);
                let method_entry = method_rc.deref().borrow();
                let method_name = method_entry.name();
                let methodref_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Methodref(method_name.to_string())).unwrap();
                bytecode.extend_from_slice(&methodref_index.to_be_bytes());
                // finally, a method call consumes the arguments on the stack, so reduce the counter
                // but, remember that a function may also push a result (if its return type isn't void), so there might be one incremental step as well
                *current_stack -= argument_count as u16 - if method_entry.result_type().is_some() { 1 } else { 0 };
            }
            SyntaxElement::Assign => {
                // first execute the right child (the result) which you then use to set the variable in the left child
                bytecode.extend_from_slice(method_bytecode(node.borrow_right(), constant_pool, sym_table, params, current_stack, max_stack, false).as_slice());
                // now the necessary value should be on the stack, so store it in the variable
                // for that we need to know what variable, so get the name
                let var_entry = node.borrow_left().unwrap().get_obj().as_ref().unwrap().deref().borrow();
                let var_name = var_entry.name();
                // with that we can first decide whether its a class variable or an argument, or a local one
                // first check the params
                if let Some((param_index, _param)) = params.iter().enumerate().find(|(_i, type_and_name)| (*type_and_name).1.as_str() == var_name) {
                    // it is a param, store to the place specified by the index
                    // write the opcode and the index into the local variables
                    bytecode.push(istore as u8);
                    bytecode.push(param_index as u8);
                }
                else if let Some((i, _name)) = sym_table.var_names().iter()
                    .filter(|name| params.iter().find(|(_t, p_name)| p_name.as_str() == name.as_str()).is_none())    // filter out params
                    .enumerate().find(|(_i, name)| var_name == (*name).as_str() ) {     // then enumerate the rest to give them an order
                    // it's a local one
                    // use the index + the number of params as an index into the local variables
                    let local_index = (i + params.len()) as u8;
                    // write the opcode and the index into the local variables
                    bytecode.push(istore as u8);
                    bytecode.push(local_index);
                } else {
                    // it has to be a class variable then
                    // find the fieldref
                    let pool_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Fieldref(var_name.to_string())).unwrap();
                    // write the opcode and the index into the pool
                    bytecode.push(putstatic as u8);
                    bytecode.extend_from_slice(&pool_index.to_be_bytes());
                }
                decrease_stack(current_stack);   // assignment works by using up an item on the stack
            }
            SyntaxElement::Var => {
                // lay the variable on the stack
                // for that we need to know what variable, so get the name
                let var_entry = node.get_obj().as_ref().unwrap().deref().borrow();
                let var_name = var_entry.name();
                // with that we can first decide whether its a class variable or an argument, or a local one
                // first check the params
                if let Some((param_index, _param)) = params.iter().enumerate().find(|(_i, type_and_name)| (*type_and_name).1.as_str() == var_name) {
                    // it is a param, so load it from the place specified by the index
                    // write the opcode and the index into the local variables
                    bytecode.push(iload as u8);
                    bytecode.push(param_index as u8);
                }
                else if let Some((i, _name)) = sym_table.var_names().iter()
                    .filter(|name| params.iter().find(|(_t, p_name)| p_name.as_str() == name.as_str()).is_none())    // filter out params
                    .enumerate().find(|(_i, name)| var_name == (*name).as_str() ) {     // then enumerate the rest to give them an order
                    // it's a local one
                    // use the index + the number of params as an index into the local variables
                    let local_index = (i + params.len()) as u8;
                    // write the opcode and the index into the local variables
                    bytecode.push(iload as u8);
                    bytecode.push(local_index);
                } else {
                    // it has to be a class variable then
                    // find the fieldref
                    let pool_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Fieldref(var_name.to_string())).unwrap();
                    // write the opcode and the index into the pool
                    bytecode.push(getstatic as u8);
                    bytecode.extend_from_slice(&pool_index.to_be_bytes());
                }
                increase_stack(current_stack, max_stack);
            }
            SyntaxElement::Const => {
                // lay the const on the stack
                // for that get the value
                let value_type = node.value_type().unwrap();
                let int_value = integer_representation(&value_type);
                // from that get the CONSTANT_Integer index
                let pool_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Integer(int_value.to_string())).unwrap();
                // write the opcode and the index into the pool
                bytecode.push(ldc_w as u8);
                bytecode.extend_from_slice(&pool_index.to_be_bytes());
                increase_stack(current_stack,  max_stack);
            }
            SyntaxElement::Binop(op) => {
                // compute the left child and then the right child and then your actual operation
                bytecode.extend_from_slice(method_bytecode(node.borrow_left(), constant_pool, sym_table, params, current_stack, max_stack, false).as_slice());
                bytecode.extend_from_slice(method_bytecode(node.borrow_right(), constant_pool, sym_table, params, current_stack, max_stack, false).as_slice());
                fn comparison_via_jump(bytecode: &mut Vec<u8>, compare_op: ByteInstruction) {
                    // comparison operations are a bit more tricky, as there is no direct operation for them
                    // (though there is lcmp which we could utilize, but not without other downsides)
                    // instead we do a conditional jump
                    // if the comparison succeeds we jump to an operation that pushes a 1
                    // if it doesn't succeed we let execution continue onto the next operation,
                    // which pushes a 0 and then jumps to the instruction after 'push 1 if comparison succeeds'
                    bytecode.push(compare_op as u8);                     // offset from if: 0
                    bytecode.extend_from_slice(&7i16.to_be_bytes());    // offset from if: 1, 2
                    bytecode.push(iconst_0 as u8);                      // offset from if: 3
                    bytecode.push(goto as u8);                          // offset from if: 4; from goto: 0
                    bytecode.extend_from_slice(&4i16.to_be_bytes());    // offset from if: 5, 6; from goto: 1, 2
                    bytecode.push(iconst_1 as u8);                      // offset from if: 7; from goto: 3
                    // next instruction: offset from goto: 4
                }
                match op {
                    Binop::Add => { bytecode.push(iadd as u8); }
                    Binop::Sub => { bytecode.push(isub as u8); }
                    Binop::Mul => { bytecode.push(imul as u8); }
                    Binop::Div => { bytecode.push(idiv as u8); }
                    Binop::Equals =>        { comparison_via_jump(&mut bytecode, if_icmpeq); }
                    Binop::Smaller =>       { comparison_via_jump(&mut bytecode, if_icmplt); }
                    Binop::SmallerEqual =>  { comparison_via_jump(&mut bytecode, if_icmple); }
                    Binop::Larger =>        { comparison_via_jump(&mut bytecode, if_icmpgt); }
                    Binop::LargerEqual =>   { comparison_via_jump(&mut bytecode, if_icmpge); }
                }
                decrease_stack(current_stack);   // the binop pops two items and the result pushes one -> -1 in total
            }
            SyntaxElement::IfElse => {
                // handle the whole if-else construction (as there is no individual case for if)

                // first prepare the bytecode for the else-case, so that we know how far we have to jump ahead iff our if-condition is true
                let bytecode_else = method_bytecode(node.borrow_right(), constant_pool, sym_table, params, current_stack, max_stack, true);
                // and also prepare the if-case, so that we know how far we have to jump after executing the else-case
                let if_node = node.borrow_left().unwrap();
                let bytecode_if = method_bytecode(if_node.borrow_right(), constant_pool, sym_table, params, current_stack, max_stack, true);
                // the first thing to write to the bytecode is the execution of the condition, so that its result is ready on the stack
                // for our if to work with afterwards
                bytecode.extend_from_slice(method_bytecode(if_node.borrow_left(), constant_pool, sym_table, params, current_stack, max_stack, false).as_slice());
                // now either a 1 or a 0 lies on the stack
                // use ifne to jump over the else-case if it's a 1
                bytecode.push(ifne as u8);
                decrease_stack(current_stack);   // ifne pops one item
                bytecode.extend_from_slice(&((bytecode_else.len() + 6) as i16).to_be_bytes()); // include the 3 bytes necessary for the index and the if itself and 3 bytes for a goto with an index after the else-code to jump over the if-code
                bytecode.extend_from_slice(bytecode_else.as_slice());
                // now place a goto to jump over the following if-case
                bytecode.push(goto as u8);
                bytecode.extend_from_slice(&((bytecode_if.len() + 3) as i16).to_be_bytes());  // include the 3 bytes necessary for the index and the goto itself
                // finally, place the if-case
                bytecode.extend_from_slice(bytecode_if.as_slice());
            }
            SyntaxElement::While => {
                // operate similarly as in the IfElse case;

                // prepare the loop bytecode, which we'll need to jump over at some point
                let bytecode_loop = method_bytecode(node.borrow_right(), constant_pool, sym_table, params, current_stack, max_stack, true);
                // the first thing to write to the bytecode is the execution of the condition, so that its result is ready on the stack
                // for our if to work with afterwards
                let bytecode_condition = method_bytecode(node.borrow_left(), constant_pool, sym_table, params, current_stack, max_stack, false);
                bytecode.extend_from_slice(bytecode_condition.as_slice());
                // now either a 1 or a 0 lies on the stack
                // use ifeq to jump over the loop-case if it's a 0
                bytecode.push(ifeq as u8);
                decrease_stack(current_stack);   // ifeq pops one item
                bytecode.extend_from_slice(&((bytecode_loop.len() + 6) as i16).to_be_bytes()); // include the 3 bytes necessary for the index and the if itself and 3 bytes for a goto with an index after the loop-code to jump back over the if-code
                bytecode.extend_from_slice(bytecode_loop.as_slice());
                // now add a goto to jump back over the while code to the condition
                bytecode.push(goto as u8);
                bytecode.extend_from_slice(&(-((bytecode_loop.len() + 3 + bytecode_condition.len()) as i16)).to_be_bytes()); // include 3 bytes for the ifeq and its index and of course the code-length of the loop and the condition
            }
            SyntaxElement::Return => {
                // if there's a right child this return is an ireturn and the child has to be computed before it can be returned
                if let Some(ret_value_node) = node.borrow_right() {
                    bytecode.extend_from_slice(method_bytecode(Some(ret_value_node), constant_pool, sym_table, params, current_stack, max_stack, false).as_slice());
                    bytecode.push(ireturn as u8);
                    decrease_stack(current_stack);   // though this is really unnecessary to account for (except for making sure that the stack-counting works)
                } else {
                    // there's no child, so this is a void return
                    bytecode.push(JVMreturn as u8);
                }
                return bytecode;    // we're done with the method, so return the bytecode
            }
            other => panic!("nonsensical syntax element in bytecode creation: {:?}", other)
        }

        if follow_link {
            node_option = node.borrow_link();
        } else {
            node_option = None;
        }
    }
    bytecode
}

fn integer_representation(value_type: &Type) -> i32 {
    match value_type {
        Type::Int(i) => *i,
        Type::Bool(b) => if *b { 1 } else { 0 },
    }
}

enum ByteInstruction {
    /// push integer 0 onto the stack
    iconst_0 = 0x03,
    /// push integer 1 onto the stack
    iconst_1 = 0x04,
    /// form: invokestatic, index_byte1, index_byte2
    invokestatic = 0xb8,
    /// load constant from pool with wide index (two bytes)
    ldc_w = 0x13,
    /// load integer from local variable store to stack (one byte index)
    iload = 0x15,
    /// remove integer from top of stack and put it into the local variable store at the given index (one byte index)
    istore = 0x36,
    /// add the two ints on top of the stack and push the result onto it
    iadd = 0x60,
    /// get value1 and then value2 from the stack and push value1 - value2 onto it
    isub = 0x64,
    /// multiply the two ints on top of the stack and push the result onto it
    imul = 0x68,
    /// get value1 and then value2 from the stack and push value1 / value2 onto it
    idiv = 0x6c,
    /// compare the top int on the stack with 0; jump to the given two-byte offset in bytecode if value == 0
    ifeq = 0x99,
    /// compare the top int on the stack with 0; jump to the given two-byte offset in bytecode if value != 0
    ifne = 0x9a,
    /// compare two ints on the stack using ==; jump to given two-byte offset in bytecode if true;
    if_icmpeq = 0x9f,
    /// compare two ints on the stack using >=; jump to given two-byte offset in bytecode if true;
    if_icmpge = 0xa2,
    /// compare two ints on the stack using >; jump to given two-byte offset in bytecode if true;
    if_icmpgt = 0xa3,
    /// compare two ints on the stack using <=; jump to given two-byte offset in bytecode if true;
    if_icmple = 0xa4,
    /// compare two ints on the stack using <; jump to given two-byte offset in bytecode if true;
    if_icmplt = 0xa1,
    /// load the static variable with the Fieldref at the given two-byte address in the pool onto the stack
    getstatic = 0xb2,
    /// put the stack top into the static variable with the Fieldref at the given two-byte address in the pool
    putstatic = 0xb3,
    /// return the int on top of the stack as the result
    ireturn = 0xac,
    /// return... nothing; still, return!
    JVMreturn = 0xb1,
    /// goto the address at the given offset (two byte index)
    goto = 0xa7,
}

fn max_locals(enter_node: &Node) -> u16 {
    // finding the number of locals in a method is easy
    // for a non-static method the first entry would be 'this', but since our methods are static there is no 'this'
    // then the number of method parameters is added
    // and finally the number of local variables
    // luckily params as well as local variables are all contained in the symbol table of the method
    let entry_rc = enter_node.get_obj().as_ref().unwrap();
    let entry = entry_rc.deref().borrow();
    let method_table_rc = entry.sym_table().unwrap();
    let method_table = method_table_rc.deref().borrow();
    method_table.var_names().len() as u16
}

/*
fn max_stack(mut node_option: Option<&Node>) -> u16 {
    // finding the maximum stack height requires walking through the method ast and checking
    // the number of stack entries necessary for each binop and method invocation
    // to start just walk through the ast until you hit a binop or a method invocation
    let mut max_stack_size = 0;
    while let Some(current_node) = node_option {
        match current_node.node_type() {
            SyntaxElement::Enter => {
                // nothing to do here, just enter the right child
                return max_stack(current_node.borrow_right());  // return it to avoid going into the next method (i.e. the link-node)
            }
            SyntaxElement::Call => {
                // to invoke a method all arguments have to be laid upon the stack
                // to get the arguments we might need to perform additional work (if they're binops or calls themselves)
                // so go through the actual arguments found in the left child and check

                // but remember that arguments are laid on the stack in inverted order (so that they're in normal order when popped)
                // for that go into the left child (i.e. the first argument) and walk to the last argument and then the second last and so on
                let method_rc = current_node.get_obj().as_ref().unwrap();
                let argument_count = method_rc.deref().borrow().params().unwrap().len();
                for i in 0..argument_count {
                    let target_index = argument_count - i;
                    let mut arg_index = 1;
                    let mut arg_option = current_node.borrow_left();
                    while let Some(arg_node) = arg_option {

                        if arg_index == target_index {
                            // get the max stack size
                            let argument_max_stack_size = max_stack(Some(arg_node));
                            // there only needs to be enough space to lay down
                            // the arguments to this point and then compute the next argument
                            max_stack_size = max(max_stack_size, i as u16 + argument_max_stack_size);
                            break;
                        }
                        arg_index += 1;
                        arg_option = arg_node.borrow_link();
                    }
                }
                max_stack_size *= 2 // MAGIC: for some reason the max_stack size desired by all jdks I tested on is always double the slots...
            }
            SyntaxElement::Assign => {
                if max_stack_size == 0 { max_stack_size = 1; } // just because an assignment might need one
                // check the right child, because it might be a binop or call
                let assign_max_stack_size = max_stack(current_node.borrow_right());
                max_stack_size = max(max_stack_size, assign_max_stack_size);
            }
            SyntaxElement::Const | SyntaxElement::Var => {
                if max_stack_size == 0 { max_stack_size = 1; } // laying the const or var on the stack needs space
            }
            SyntaxElement::Binop(_) => {
                // a binop always needs at least two slots on the stack
                // actually it needs at least how ever many are necessary to compute the left child
                max_stack_size = max(max_stack_size, max_stack(current_node.borrow_left()));
                // then, after the left child is computed, it only needs 1 plus the slots necessary to compute the right child
                max_stack_size = max(max_stack_size, 1 + max_stack(current_node.borrow_right()));
            }
            SyntaxElement::IfElse | SyntaxElement::If | SyntaxElement::While => {
                max_stack_size = max(max_stack_size, max_stack(current_node.borrow_left())); // if / condition
                max_stack_size = max(max_stack_size, max_stack(current_node.borrow_right())); // statement block
            }
            SyntaxElement::Return => {
                if max_stack_size == 0 { max_stack_size = 1; } // just because a return might need one
                // check the right child, because it might be a binop or call
                let return_max_stack_size = max_stack(current_node.borrow_right());
                max_stack_size = max(max_stack_size, return_max_stack_size);
            }
            _ => {}
        }
        node_option = current_node.borrow_link();
    }
    max_stack_size as u16
}
*/

/// write the number of fields and then the field_info array itself, describing the field
fn write_fields(bytecode: &mut Vec<u8>, init_node: &Node, sym_table: &SymTable, constant_pool: &ConstantPool) {
    // start with the number of fields
    let field_count = sym_table.var_names_with_type().len() as u16;
    bytecode.extend_from_slice(&field_count.to_be_bytes());

    // then write all the FINAL FIELDS
    // an init_node has at most one child: the left one, which is the first assignment of a final variable
    let mut final_names = Vec::<String>::new();
    let mut assign_option = init_node.borrow_left();
    while let Some(assign_node) = assign_option {
        // first get the var name out of the left child
        let var_node = assign_node.borrow_left().unwrap();
        let var_entry = var_node.get_obj().as_ref().unwrap().deref().borrow();
        let var_name = var_entry.name();
        final_names.push(var_name.to_string());
        // now get the value and type of the final variable out of the right child
        let value_node = assign_node.borrow_right().unwrap();
        let value = value_node.value_type().unwrap();

        // now: u16: access_flags, u16: name_index, u16: descriptor_index, u16: attributes_count, attributes[attributes_count]
        bytecode.extend_from_slice(b"\x00\x18");    // static (0x0008) and final (0x0010)
        let field_name_index = *constant_pool.get_index(&CONSTANT_Utf8(var_name.to_string())).unwrap();
        bytecode.extend_from_slice(&field_name_index.to_be_bytes());
        let descriptor = match value {
            Type::Int(_) => "I",
            Type::Bool(_) => "Z",
        };
        let descriptor_index = *constant_pool.get_index(&CONSTANT_Utf8(descriptor.to_string())).unwrap();
        bytecode.extend_from_slice(&descriptor_index.to_be_bytes());
        // the attributes now have to contain the constant value that this constant is set to
        bytecode.extend_from_slice(&1u16.to_be_bytes());    // so exactly one attribute
        // attribute = u16: ConstantValue_index, u32: attribute_length, u16: constant_index
        let ConstantValue_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8("ConstantValue".to_string())).unwrap();
        bytecode.extend_from_slice(&ConstantValue_index.to_be_bytes());
        // attribute_length is 2
        bytecode.extend_from_slice(&2u32.to_be_bytes());
        let actual_value = integer_representation(&value);
        let actual_value_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Integer(actual_value.to_string())).unwrap();
        bytecode.extend_from_slice(&actual_value_index.to_be_bytes());

        // then go on towards the next assignment if there is one
        assign_option = assign_node.borrow_link();
    }
    // now the NON-FINAL FIELDS
    for (var_name, var_type) in sym_table.var_names_with_type() {
        // first check whether its one of the final ones and skip it if true
        if final_names.contains(&var_name) { continue; }
        // now: u16: access_flags, u16: name_index, u16: descriptor_index, u16: attributes_count, attributes[attributes_count]
        bytecode.extend_from_slice(b"\x00\x08");    // static (0x0008)
        let field_name_index = *constant_pool.get_index(&CONSTANT_Utf8(var_name)).unwrap();
        bytecode.extend_from_slice(&field_name_index.to_be_bytes());
        let descriptor = match var_type {
            Type::Int(_) => "I",
            Type::Bool(_) => "Z",
        };
        let descriptor_index = *constant_pool.get_index(&CONSTANT_Utf8(descriptor.to_string())).unwrap();
        bytecode.extend_from_slice(&descriptor_index.to_be_bytes());
        // non constant fields don't need any attributes
        bytecode.extend_from_slice(&0u16.to_be_bytes());    // so exactly zero attributes
    }
}

/// writes a two-byte bitflag specifying the (access-)properties of this class
fn write_access_flags(bytecode: &mut Vec<u8>) {
    bytecode.extend_from_slice(b"\x04\x01");    // ABSTRACT and PUBLIC
}
/// writes the class index, the super-class index and zero for the number of interfaces used
fn write_class_indexes_and_interfaces(bytecode: &mut Vec<u8>, constant_pool: &ConstantPool, class_name: &str) {
    let class_index = constant_pool.get_index(&CPoolEntry::CONSTANT_Class(class_name.to_string()));
    bytecode.extend_from_slice( &((*class_index.unwrap()) as u16).to_be_bytes() );    // class
    let super_index = constant_pool.get_index(&CPoolEntry::CONSTANT_Class("java/lang/Object".to_string()));
    bytecode.extend_from_slice( &((*super_index.unwrap()) as u16).to_be_bytes() );    // super class (Object)
    bytecode.extend_from_slice(b"\x00\x00");    // interface count
}

fn write_head(bytecode: &mut Vec<u8>) {
    // start off with 0xCAFEBABE, as law wills it
    bytecode.extend_from_slice(b"\xCA\xFE\xBA\xBE");
    // as for class file version let's go for 45, as that translates to Java 1.1 (https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html)
    // (since we really don't need anything fancy from newer versions)
    // store it in big-endian encoding as that's what the format demands
    // for the minor just take 0
    bytecode.extend_from_slice(&0u16.to_be_bytes());
    //bytecode.extend_from_slice(&45u16.to_be_bytes());
    bytecode.extend_from_slice(&49u16.to_be_bytes()); // EDIT: choose something higher (here Java 5), as compatibility with Java 1.1 is hard to find nowadays...
    //bytecode.extend_from_slice(&51u16.to_be_bytes());   // this would translate to Java 7, but that would sadly require implementing StackMapFrame...
}

/// a helper struct to hold both the buffer later used as the actual constant pool inside the file,
/// as well as a dictionary allowing us to easily find the corresponding indices
struct ConstantPool {
    buffer: Vec<u8>,
    indices: HashMap<CPoolEntry, u16>
}

impl ConstantPool {
    pub fn get_index(&self, entry: &CPoolEntry) -> Option<&u16> {
        self.indices.get(entry)
    }

    pub fn new(ast: &Node, table: &SymTable) -> Self {
        let buffer: Vec<u8> = vec![];
        let indices = HashMap::<CPoolEntry, u16>::new();
        let mut pool = Self {
            buffer,
            indices,
        };

        // start off with all constants used
        pool.write_constants(Some(ast));
        // then the class name and a CONSTANT_Class for the class itself
        let class_index = pool.write_class_name(ast);
        // now the superclass (which is always the same: Object)
        pool.write_super_class();
        // next add all fields
        pool.write_fields(table, class_index);
        // now all methods
        pool.write_methods(table, class_index);
        // and finally add some other special strings that we need
        pool.write_special_strings();

        pool
    }

    /// adds a CONSTANT_Class for the class itself and also a Utf8-String holding its name
    fn write_class_name(&mut self, class_node: &Node) -> u16 {
        // first find the name
        let class_sym_entry = class_node.get_obj().as_ref().expect("starting class node without obj").deref().borrow();
        let class_name = class_sym_entry.name();
        // then store it
        let name_index = self.write_utf8(class_name);
        // and also store it with a ".class" added (for the final source file attribute)
        let mut file_name = class_name.to_string();
        file_name.push_str(".class");
        self.write_utf8(file_name.as_str());
        // now store a CONSTANT_Class value for the class
        self.write_CONSTANT_Class(class_name, name_index)
    }

    /// adds a CONSTANT_Class for the super-class (always Object) and also a Utf8-String holding the name
    fn write_super_class(&mut self) -> u16 {
        // first store the name string in the constant pool
        let class_name = "java/lang/Object";
        let name_index = self.write_utf8(class_name);

        // now store a CONSTANT_Class value for the class
        self.write_CONSTANT_Class(class_name, name_index)
    }
    /// starts a new entry and returns the constant pool index of it, if no such entry is already present;
    /// if there already is one it returns None
    fn start_entry(&mut self, entry: &CPoolEntry) -> Option<u16> {
        if self.indices.get(&entry).is_none() {
            let tag = entry.tag_byte();
            let next_index = (self.indices.len() + 1) as u16;
            self.indices.insert((*entry).clone(), next_index);
            self.buffer.push(tag);
            Some(next_index)
        } else {
            None
        }
    }
    /// writes a string to the constant pool, if it isn't already present there;
    /// returns the index to where it was written, or the index of the already present one;
    fn write_utf8(&mut self, string: &str) -> u16 {
        let entry = CPoolEntry::CONSTANT_Utf8(string.to_string());
        if let Some(index) = self.start_entry(&entry) {
            let bytes = string.as_bytes();
            self.buffer.extend_from_slice(&(bytes.len() as u16).to_be_bytes());
            self.buffer.extend_from_slice(bytes);
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
    /// writes a CONSTANT_Class to the constant pool, if it isn't already present there;
    /// returns the index to where it was written, or the index of the already present one;
    fn write_CONSTANT_Class(&mut self, string: &str, name_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_Class(string.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&name_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
    /// writes a CONSTANT_NameAndType to the constant pool, if it isn't already present there;
    /// returns the index to where it was written, or the index of the already present one;
    fn write_CONSTANT_NameAndType(&mut self, name: &str, name_index: u16, type_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_NameAndType(name.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&name_index.to_be_bytes());
            self.buffer.extend_from_slice(&type_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
    /*  OBSOLETE DUE TO write_constants
    /// find all final fields in this init node and add their values to the pool;
    fn write_final_field_values(&mut self, init_node: &Node) {
        // an init_node has at most one child: the left one, which is the first assignment of a final variable
        let mut assign_option = init_node.borrow_left();
        while let Some(assign_node) = assign_option {
            // get the value and type of the final variable out of the right child
            let value_node = assign_node.borrow_right().unwrap();
            let value = value_node.value_type().unwrap();

            // and then write the value to the pool
            let int_val = match value {
                Type::Int(i) => i,
                Type::Bool(b) => if b { 1i32 } else { 0i32 },
            };
            self.write_CONSTANT_Integer(int_val);   // currently only integer-variants are even possible

            // then go on towards the next assignment if there is one
            assign_option = assign_node.borrow_link();
        }
    }
    */
    /// find all non-final fields in the class symbol table and add them to the pool
    fn write_fields(&mut self, table: &SymTable, class_index: u16) {
        // go through all class fields and add them
        for (var_name, var_type) in table.var_names_with_type() {
            // first write the name
            let name_index = self.write_utf8(var_name.as_str());
            // then a special utf8 string that contains the type
            let type_string_index = match var_type {
                Type::Int(_) => self.write_utf8("I"),
                Type::Bool(_) => {
                    // should never happen as the current language specification doesn't allow it,
                    // but it doesn't hurt to implement it here in case the spec changes
                    self.write_utf8("Z")    // turns out "B" is for the byte type actually
                }
            };
            // and then write a CONSTANT_NameAndType linking to the two
            let name_and_type_index = self.write_CONSTANT_NameAndType(var_name.as_str(), name_index, type_string_index);
            // finally write the CONSTANT_Fieldref linking to the class and the name_and_type
            self.write_CONSTANT_Fieldref(var_name.as_str(), class_index, name_and_type_index);
        }
    }
    /// find methods and write them to the pool
    fn write_methods(&mut self, table: &SymTable, class_index: u16) {
        // go through all class fields and add them
        for (proc_name, sym_entry) in table.procedures() {
            let sym_entry = sym_entry.deref().borrow();
            // first write the name
            let name_index = self.write_utf8(proc_name.as_str());

            // then a special utf8 string that contains the signature
            let m_descriptor = Self::method_descriptor(&sym_entry);
            let type_string_index = self.write_utf8(m_descriptor.as_str());

            // and then write a CONSTANT_NameAndType linking to the two
            let name_and_type_index = self.write_CONSTANT_NameAndType(proc_name.as_str(), name_index, type_string_index);
            // finally write the CONSTANT_Methodref linking to the class and the name_and_type
            self.write_CONSTANT_Methodref(proc_name, class_index, name_and_type_index);
        }
    }
    /// goes through the whole AST to find all integer literals used, to add them to the pool;
    fn write_constants(&mut self, mut node_option: Option<&Node>) {
        // the left is already covered, so search the right
        while let Some(node) = node_option {
            // first write constants of the left
            self.write_constants(node.borrow_left());
            // then your own (if you are a literal node that is)
            if let SyntaxElement::Const = node.node_type() {
                let value = node.value_type().unwrap();
                let jvm_integer_value = integer_representation(&value);
                self.write_CONSTANT_Integer(jvm_integer_value);
            }
            // and then write all constants on the right
            self.write_constants(node.borrow_right());
            // finally go on to the next instruction
            node_option = node.borrow_link();
        }
    }

    /// returns a string containing the method descriptor of the method behind the SymEntry
    pub fn method_descriptor(sym_entry: &SymEntry) -> String {
        // the form is: ( {FieldType} ) ReturnDescriptor
        // ReturnDescriptor = FieldType | VoidDescriptor
        // parameters:
        let mut m_descriptor = "(".to_string();
        for (p_type, _name) in sym_entry.params().unwrap() {
            let field_descriptor = match p_type {
                Type::Int(_) => "I",
                Type::Bool(_) => "Z",
            };
            m_descriptor.push_str(field_descriptor)
        }
        m_descriptor.push(')');
        // return type:
        let return_descriptor = match sym_entry.result_type().unwrap() {
            ResultType::Int => 'I',
            ResultType::Void => 'V',
        };
        m_descriptor.push(return_descriptor);
        m_descriptor
    }

    fn write_CONSTANT_Methodref(&mut self, method_name: &str, class_index: u16, name_and_type_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_Methodref(method_name.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&class_index.to_be_bytes());
            self.buffer.extend_from_slice(&name_and_type_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }

    fn write_CONSTANT_Fieldref(&mut self, field_name: &str, class_index: u16, name_and_type_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_Fieldref(field_name.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&class_index.to_be_bytes());
            self.buffer.extend_from_slice(&name_and_type_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }

    pub fn flush(&self, buffer: &mut Vec<u8>) {
        // constant_pool_count
        buffer.extend_from_slice(&((self.indices.len() + 1) as u16).to_be_bytes());
        // constant_pool
        buffer.extend_from_slice(self.buffer.as_slice());
    }
    fn write_special_strings(&mut self) {
        self.write_utf8("<clinit>");
        self.write_utf8("()V");
        self.write_utf8("Code");
        self.write_utf8("SourceFile");
        self.write_utf8("ConstantValue");
    }
    fn write_CONSTANT_Integer(&mut self, integer: i32) -> u16 {
        let entry = CPoolEntry::CONSTANT_Integer(integer.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&integer.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
}

/// an enum specifying the different things that can be stored in the constant pool;
/// meant to be used as a key value to find items inside the constant pool dictionary;
///
/// the string contained specifies the name of the higher level construct it belongs to
/// (i.e. "counter" for a variable called "counter", "m3" for a method called "m3", etc.)
#[derive(Debug, Eq, Derivative, Clone)]
#[derivative(PartialEq, Hash)]
enum CPoolEntry {
    CONSTANT_Utf8(String),
    CONSTANT_Integer(String),
    CONSTANT_Class(String),
    CONSTANT_Fieldref(String),
    CONSTANT_Methodref(String),
    CONSTANT_NameAndType(String),
}

impl CPoolEntry {
    pub fn tag_byte(&self) -> u8 {
        match self {
            CPoolEntry::CONSTANT_Utf8(_) => 1,
            //CPoolEntry::CONSTANT_Unicode => 2,
            CPoolEntry::CONSTANT_Integer(_) => 3,
            //CPoolEntry::CONSTANT_Float => 4,
            //CPoolEntry::CONSTANT_Long => 5,
            //CPoolEntry::CONSTANT_Double => 6,
            CPoolEntry::CONSTANT_Class(_) => 7,
            //CPoolEntry::CONSTANT_String => 8,
            CPoolEntry::CONSTANT_Fieldref(_) => 9,
            CPoolEntry::CONSTANT_Methodref(_) => 10,
            //CPoolEntry::CONSTANT_InterfaceMethodref => 11,
            CPoolEntry::CONSTANT_NameAndType(_) => 12,
        }
    }
}