//! code for generating JVM-bytecode out of an AST and a symbol table for a JavaSST class

use std::collections::HashMap;
use std::fs::File;
use std::io::Write;
use derivative::Derivative;
use crate::parser::ast::Node;
use crate::parser::bytecode::CPoolEntry::CONSTANT_Utf8;
use crate::parser::error::ParseResult;
use crate::parser::sym_table::{ResultType, SymTable, Type};

/// takes an AST and a symbol table belonging to it and creates JVM-bytecode from it for the given class
pub fn generate(ast: &Node, table: &SymTable) -> ParseResult {
    // get the name of the class, as we need it in the bytecode and later to name the file
    let class_entry = ast.get_obj().as_ref().expect("starting class node without obj").borrow();
    let class_name = class_entry.name();

    // get the class sym table out of the head table (as the class' table is the only table we really care about)
    let table_rc = table.get_entry(class_name).unwrap().borrow().sym_table().unwrap();
    let table = table_rc.borrow();

    // start with an empty vec of bytes to be filled with the generated bytecode
    let mut bytecode: Vec<u8> = vec![];

    write_head(&mut bytecode);

    // create the constant_pool and write it to the buffer
    let constant_pool = ConstantPool::new(ast, &table);
    constant_pool.flush(&mut bytecode);
    
    write_access_flags(&mut bytecode);
    write_class_indexes_and_interfaces(&mut bytecode, &constant_pool, class_name);
    write_fields(&mut bytecode, ast.borrow_left().unwrap(), &table, &constant_pool);
    write_methods(&mut bytecode, &table, &constant_pool);
    write_attributes(&mut bytecode, &constant_pool, class_name);

    // open a new output file and write all bytes into it
    let mut file = File::create(format!("{}.class", class_name)).expect("couldn't create file o.class");
    file.write(bytecode.as_slice()).unwrap();

    Ok(())
}
/// there is only one attribute for a class: its source file name
fn write_attributes(bytecode: &mut Vec<u8>, constant_pool: &ConstantPool, class_name: &str) {
    bytecode.extend_from_slice(&1u16.to_be_bytes());    // attribute count
    let SourceFile_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8("SourceFile".to_string())).unwrap();
    bytecode.extend_from_slice(&SourceFile_index.to_be_bytes());    // attribute name index
    bytecode.extend_from_slice(&2u32.to_be_bytes());    // attribute length
    let mut file_name = class_name.to_string();
    file_name.push_str(".class");
    let file_name_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8(file_name)).unwrap();
    bytecode.extend_from_slice(&file_name_index.to_be_bytes());    // file name index
}

fn write_methods(bytecode: &mut Vec<u8>, table: &SymTable, constant_pool: &ConstantPool) {
    // start with the number of methods
    let method_count = table.procedures().count() as u16;
    //bytecode.extend_from_slice(&method_count.to_be_bytes());    // method count
    bytecode.extend_from_slice(&0u16.to_be_bytes());    // method count DEBUG
    //todo!()
}

/// write the number of fields and then the field_info array itself, describing the field
fn write_fields(bytecode: &mut Vec<u8>, init_node: &Node, sym_table: &SymTable, constant_pool: &ConstantPool) {
    // start with the number of fields
    let field_count = sym_table.var_names_with_type().len() as u16;
    bytecode.extend_from_slice(&field_count.to_be_bytes());

    // then write all the FINAL FIELDS
    // an init_node has at most one child: the left one, which is the first assignment of a final variable
    let mut final_names = Vec::<String>::new();
    let mut assign_option = init_node.borrow_left();
    while let Some(assign_node) = assign_option {
        // first get the var name out of the left child
        let var_node = assign_node.borrow_left().unwrap();
        let var_entry = var_node.get_obj().as_ref().unwrap().borrow();
        let var_name = var_entry.name();
        final_names.push(var_name.to_string());
        // now get the value and type of the final variable out of the right child
        let value_node = assign_node.borrow_right().unwrap();
        let value = value_node.value_type().unwrap();

        // now: u16: access_flags, u16: name_index, u16: descriptor_index, u16: attributes_count, attributes[attributes_count]
        bytecode.extend_from_slice(b"\x00\x18");    // static (0x0008) and final (0x0010)
        let field_name_index = *constant_pool.get_index(&CONSTANT_Utf8(var_name.to_string())).unwrap();
        bytecode.extend_from_slice(&field_name_index.to_be_bytes());
        let descriptor = match value {
            Type::Int(_) => "I",
            Type::Bool(_) => "Z",
        };
        let descriptor_index = *constant_pool.get_index(&CONSTANT_Utf8(descriptor.to_string())).unwrap();
        bytecode.extend_from_slice(&descriptor_index.to_be_bytes());
        // the attributes now have to contain the constant value that this constant is set to
        bytecode.extend_from_slice(&1u16.to_be_bytes());    // so exactly one attribute
        // attribute = u16: ConstantValue_index, u32: attribute_length, u16: constant_index
        let ConstantValue_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Utf8("ConstantValue".to_string())).unwrap();
        bytecode.extend_from_slice(&ConstantValue_index.to_be_bytes());
        // attribute_length is 2
        bytecode.extend_from_slice(&2u32.to_be_bytes());
        let actual_value = match value {
            Type::Int(i) => i,
            Type::Bool(b) => if b { 1i32 } else { 0i32 },
        };
        let actual_value_index = *constant_pool.get_index(&CPoolEntry::CONSTANT_Integer(actual_value.to_string())).unwrap();
        bytecode.extend_from_slice(&actual_value_index.to_be_bytes());

        // then go on towards the next assignment if there is one
        assign_option = assign_node.borrow_link();
    }
    // now the NON-FINAL FIELDS
    for (var_name, var_type) in sym_table.var_names_with_type() {
        // first check whether its one of the final ones and skip it if true
        if final_names.contains(&var_name) { continue; }
        // now: u16: access_flags, u16: name_index, u16: descriptor_index, u16: attributes_count, attributes[attributes_count]
        bytecode.extend_from_slice(b"\x00\x08");    // static (0x0008)
        let field_name_index = *constant_pool.get_index(&CONSTANT_Utf8(var_name)).unwrap();
        bytecode.extend_from_slice(&field_name_index.to_be_bytes());
        let descriptor = match var_type {
            Type::Int(_) => "I",
            Type::Bool(_) => "Z",
        };
        let descriptor_index = *constant_pool.get_index(&CONSTANT_Utf8(descriptor.to_string())).unwrap();
        bytecode.extend_from_slice(&descriptor_index.to_be_bytes());
        // non constant fields don't need any attributes
        bytecode.extend_from_slice(&0u16.to_be_bytes());    // so exactly zero attributes
    }
}

/// writes a two-byte bitflag specifying the (access-)properties of this class
fn write_access_flags(bytecode: &mut Vec<u8>) {
    bytecode.extend_from_slice(b"\x00\x01");    // PUBLIC
}
/// writes the class index, the super-class index and zero for the number of interfaces used
fn write_class_indexes_and_interfaces(bytecode: &mut Vec<u8>, constant_pool: &ConstantPool, class_name: &str) {
    let class_index = constant_pool.get_index(&CPoolEntry::CONSTANT_Class(class_name.to_string()));
    bytecode.extend_from_slice( &((*class_index.unwrap()) as u16).to_be_bytes() );    // class
    let super_index = constant_pool.get_index(&CPoolEntry::CONSTANT_Class("java/lang/Object".to_string()));
    bytecode.extend_from_slice( &((*super_index.unwrap()) as u16).to_be_bytes() );    // super class (Object)
    bytecode.extend_from_slice(b"\x00\x00");    // interface count
}

fn write_head(bytecode: &mut Vec<u8>) {
    // start off with 0xCAFEBABE, as law wills it
    bytecode.extend_from_slice(b"\xCA\xFE\xBA\xBE");
    // as for class file version let's go for 45, as that translates to Java 1.1 (https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html)
    // (since we really don't need anything fancy from newer versions)
    // store it in big-endian encoding as that's what the format demands
    // for the minor just take 0
    bytecode.extend_from_slice(&0u16.to_be_bytes());
    bytecode.extend_from_slice(&45u16.to_be_bytes());
}

/// a helper struct to hold both the buffer later used as the actual constant pool inside the file,
/// as well as a dictionary allowing us to easily find the corresponding indices
struct ConstantPool {
    buffer: Vec<u8>,
    indices: HashMap<CPoolEntry, u16>
}

impl ConstantPool {
    pub fn get_index(&self, entry: &CPoolEntry) -> Option<&u16> {
        self.indices.get(entry)
    }

    pub fn new(ast: &Node, table: &SymTable) -> Self {
        let buffer: Vec<u8> = vec![];
        let indices = HashMap::<CPoolEntry, u16>::new();
        let mut pool = Self {
            buffer,
            indices,
        };

        // first the class name and a CONSTANT_Class for the class itself
        let class_index = pool.write_class_name(ast);
        // now the superclass (which is always the same: Object)
        pool.write_super_class();
        // next add all fields
        pool.write_fields(table, class_index);
        // and the values of all constants
        pool.write_final_field_values(ast.borrow_left().unwrap());
        // now all methods
        pool.write_methods(table, class_index);
        // and finally add some other special strings that we need
        pool.write_special_strings();

        pool
    }

    /// adds a CONSTANT_Class for the class itself and also a Utf8-String holding its name
    fn write_class_name(&mut self, class_node: &Node) -> u16 {
        // first find the name
        let class_sym_entry = class_node.get_obj().as_ref().expect("starting class node without obj").borrow();
        let class_name = class_sym_entry.name();
        // then store it
        let name_index = self.write_utf8(class_name);
        // and also store it with a ".class" added (for the final source file attribute)
        let mut file_name = class_name.to_string();
        file_name.push_str(".class");
        self.write_utf8(file_name.as_str());
        // now store a CONSTANT_Class value for the class
        self.write_CONSTANT_Class(class_name, name_index)
    }

    /// adds a CONSTANT_Class for the super-class (always Object) and also a Utf8-String holding the name
    fn write_super_class(&mut self) -> u16 {
        // first store the name string in the constant pool
        let class_name = "java/lang/Object";
        let name_index = self.write_utf8(class_name);

        // now store a CONSTANT_Class value for the class
        self.write_CONSTANT_Class(class_name, name_index)
    }
    /// starts a new entry and returns the constant pool index of it, if no such entry is already present;
    /// if there already is one it returns None
    fn start_entry(&mut self, entry: &CPoolEntry) -> Option<u16> {
        if self.indices.get(&entry).is_none() {
            let tag = entry.tag_byte();
            let next_index = (self.indices.len() + 1) as u16;
            self.indices.insert((*entry).clone(), next_index);
            self.buffer.push(tag);
            Some(next_index)
        } else {
            None
        }
    }
    /// writes a string to the constant pool, if it isn't already present there;
    /// returns the index to where it was written, or the index of the already present one;
    fn write_utf8(&mut self, string: &str) -> u16 {
        let entry = CPoolEntry::CONSTANT_Utf8(string.to_string());
        if let Some(index) = self.start_entry(&entry) {
            //println!("WRITING: {}", string);
            let bytes = string.as_bytes();
            self.buffer.extend_from_slice(&(bytes.len() as u16).to_be_bytes());
            self.buffer.extend_from_slice(bytes);
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
    /// writes a CONSTANT_Class to the constant pool, if it isn't already present there;
    /// returns the index to where it was written, or the index of the already present one;
    fn write_CONSTANT_Class(&mut self, string: &str, name_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_Class(string.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&name_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
    /// writes a CONSTANT_NameAndType to the constant pool, if it isn't already present there;
    /// returns the index to where it was written, or the index of the already present one;
    fn write_CONSTANT_NameAndType(&mut self, name: &str, name_index: u16, type_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_NameAndType(name.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&name_index.to_be_bytes());
            self.buffer.extend_from_slice(&type_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }

    /// find all final fields in this init node and add their values to the pool;
    fn write_final_field_values(&mut self, init_node: &Node) {
        // an init_node has at most one child: the left one, which is the first assignment of a final variable
        let mut assign_option = init_node.borrow_left();
        while let Some(assign_node) = assign_option {
            // get the value and type of the final variable out of the right child
            let value_node = assign_node.borrow_right().unwrap();
            let value = value_node.value_type().unwrap();

            // and then write the value to the pool
            let int_val = match value {
                Type::Int(i) => i,
                Type::Bool(b) => if b { 1i32 } else { 0i32 },
            };
            self.write_CONSTANT_Integer(int_val);   // currently only integer-variants are even possible

            // then go on towards the next assignment if there is one
            assign_option = assign_node.borrow_link();
        }
    }
    /// find all non-final fields in the class symbol table and add them to the pool
    fn write_fields(&mut self, table: &SymTable, class_index: u16) {
        // go through all class fields and add them
        for (var_name, var_type) in table.var_names_with_type() {
            // first write the name
            let name_index = self.write_utf8(var_name.as_str());
            // then a special utf8 string that contains the type
            let type_string_index = match var_type {
                Type::Int(_) => self.write_utf8("I"),
                Type::Bool(_) => {
                    // should never happen as the current language specification doesn't allow it,
                    // but it doesn't hurt to implement it here in case the spec changes
                    self.write_utf8("Z")    // turns out "B" is for the byte type actually
                }
            };
            // and then write a CONSTANT_NameAndType linking to the two
            let name_and_type_index = self.write_CONSTANT_NameAndType(var_name.as_str(), name_index, type_string_index);
            // finally write the CONSTANT_Fieldref linking to the class and the name_and_type
            self.write_CONSTANT_Fieldref(var_name.as_str(), class_index, name_and_type_index);
        }
    }
    /// find methods and write them to the pool
    fn write_methods(&mut self, table: &SymTable, class_index: u16) {
        // go through all class fields and add them
        for (proc_name, sym_entry) in table.procedures() {
            let sym_entry = sym_entry.borrow();
            // first write the name
            let name_index = self.write_utf8(proc_name.as_str());

            // then a special utf8 string that contains the signature
            // the form is: ( {FieldType} ) ReturnDescriptor
            // ReturnDescriptor = FieldType | VoidDescriptor

            // parameters:
            let mut m_descriptor = "(".to_string();
            for (p_type, _name) in sym_entry.params().unwrap() {
                let field_descriptor = match p_type {
                    Type::Int(_) => "I",
                    Type::Bool(_) => "Z",
                };
                m_descriptor.push_str(field_descriptor)
            }
            m_descriptor.push(')');
            // return type:
            let return_descriptor = match sym_entry.result_type().unwrap() {
                ResultType::Int => 'I',
                ResultType::Void => 'V',
            };
            m_descriptor.push(return_descriptor);
            let type_string_index = self.write_utf8(m_descriptor.as_str());

            // and then write a CONSTANT_NameAndType linking to the two
            let name_and_type_index = self.write_CONSTANT_NameAndType(proc_name.as_str(), name_index, type_string_index);
            // finally write the CONSTANT_Methodref linking to the class and the name_and_type
            self.write_CONSTANT_Methodref(proc_name, class_index, name_and_type_index);
        }
    }

    fn write_CONSTANT_Methodref(&mut self, method_name: &str, class_index: u16, name_and_type_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_Methodref(method_name.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&class_index.to_be_bytes());
            self.buffer.extend_from_slice(&name_and_type_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }

    fn write_CONSTANT_Fieldref(&mut self, field_name: &str, class_index: u16, name_and_type_index: u16) -> u16 {
        let entry = CPoolEntry::CONSTANT_Fieldref(field_name.to_string());
        if let Some(index) = self.start_entry(&entry) {
            self.buffer.extend_from_slice(&class_index.to_be_bytes());
            self.buffer.extend_from_slice(&name_and_type_index.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }

    pub fn flush(&self, buffer: &mut Vec<u8>) {
        // constant_pool_count
        buffer.extend_from_slice(&((self.indices.len() + 1) as u16).to_be_bytes());
        // constant_pool
        buffer.extend_from_slice(self.buffer.as_slice());
    }
    fn write_special_strings(&mut self) {
        self.write_utf8("<clinit>");
        self.write_utf8("LineNumberTable");
        self.write_utf8("Code");
        self.write_utf8("SourceFile");
        self.write_utf8("ConstantValue");
    }
    fn write_CONSTANT_Integer(&mut self, integer: i32) -> u16 {
        let entry = CPoolEntry::CONSTANT_Integer(integer.to_string());
        if let Some(index) = self.start_entry(&entry) {
            //println!("WRITING int: {}", integer);
            self.buffer.extend_from_slice(&integer.to_be_bytes());
            index
        } else {
            *self.indices.get(&entry).unwrap()
        }
    }
}

/// an enum specifying the different things that can be stored in the constant pool;
/// meant to be used as a key value to find items inside the constant pool dictionary;
///
/// the string contained specifies the name of the higher level construct it belongs to
/// (i.e. "counter" for a variable called "counter", "m3" for a method called "m3", etc.)
#[derive(Debug, Eq, Derivative, Clone)]
#[derivative(PartialEq, Hash)]
enum CPoolEntry {
    CONSTANT_Utf8(String),
    //CONSTANT_Unicode,
    CONSTANT_Integer(String),
    CONSTANT_Class(String),
    //CONSTANT_String,
    CONSTANT_Fieldref(String),
    CONSTANT_Methodref(String),
    //CONSTANT_InterfaceMethodref,
    CONSTANT_NameAndType(String),
}

impl CPoolEntry {
    pub fn tag_byte(&self) -> u8 {
        match self {
            CPoolEntry::CONSTANT_Utf8(_) => 1,
            //CPoolEntry::CONSTANT_Unicode => 2,
            CPoolEntry::CONSTANT_Integer(_) => 3,
            //CPoolEntry::CONSTANT_Float => 4,
            //CPoolEntry::CONSTANT_Long => 5,
            //CPoolEntry::CONSTANT_Double => 6,
            CPoolEntry::CONSTANT_Class(_) => 7,
            //CPoolEntry::CONSTANT_String => 8,
            CPoolEntry::CONSTANT_Fieldref(_) => 9,
            CPoolEntry::CONSTANT_Methodref(_) => 10,
            //CPoolEntry::CONSTANT_InterfaceMethodref => 11,
            CPoolEntry::CONSTANT_NameAndType(_) => 12,
        }
    }
}